/**
 * AutoSaveSubscription Entity
 *
 * Represents a fan's subscription to automatically save an artist's future releases.
 * Domain entity with business logic and validation.
 */

export interface AutoSaveSubscriptionProps {
  id: string;
  submissionId: string;
  spotifyUserId: string;
  artistUserId: number;
  artistSpotifyId: string;
  accessTokenEncrypted: string;
  refreshTokenEncrypted: string;
  tokenExpiresAt: Date;
  active: boolean;
  lastCheckAt?: Date | null;
  nextCheckAt?: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

export class AutoSaveSubscription {
  private constructor(private readonly props: AutoSaveSubscriptionProps) {
    this.validate();
  }

  private validate(): void {
    if (!this.props.spotifyUserId) {
      throw new Error('Spotify user ID is required');
    }
    if (!this.props.artistSpotifyId) {
      throw new Error('Artist Spotify ID is required');
    }
    if (!this.props.accessTokenEncrypted) {
      throw new Error('Access token is required');
    }
    if (!this.props.refreshTokenEncrypted) {
      throw new Error('Refresh token is required');
    }
  }

  // Getters
  get id(): string {
    return this.props.id;
  }
  get submissionId(): string {
    return this.props.submissionId;
  }
  get spotifyUserId(): string {
    return this.props.spotifyUserId;
  }
  get artistUserId(): number {
    return this.props.artistUserId;
  }
  get artistSpotifyId(): string {
    return this.props.artistSpotifyId;
  }
  get accessTokenEncrypted(): string {
    return this.props.accessTokenEncrypted;
  }
  get refreshTokenEncrypted(): string {
    return this.props.refreshTokenEncrypted;
  }
  get tokenExpiresAt(): Date {
    return this.props.tokenExpiresAt;
  }
  get active(): boolean {
    return this.props.active;
  }
  get lastCheckAt(): Date | null | undefined {
    return this.props.lastCheckAt;
  }
  get nextCheckAt(): Date | null | undefined {
    return this.props.nextCheckAt;
  }
  get createdAt(): Date {
    return this.props.createdAt;
  }
  get updatedAt(): Date {
    return this.props.updatedAt;
  }

  /**
   * Check if token is expired or will expire soon
   * @param bufferMinutes - Minutes before expiry to consider expired (default: 5)
   * @returns True if token needs refresh
   */
  isTokenExpired(bufferMinutes: number = 5): boolean {
    const bufferMs = bufferMinutes * 60 * 1000;
    const expiryWithBuffer = new Date(this.props.tokenExpiresAt.getTime() - bufferMs);
    return new Date() >= expiryWithBuffer;
  }

  /**
   * Check if subscription is due for checking
   * @returns True if should check for new releases
   */
  isDueForCheck(): boolean {
    if (!this.props.active) {
      return false;
    }

    // If never checked, it's due
    if (!this.props.nextCheckAt) {
      return true;
    }

    // If next check time has passed
    return new Date() >= this.props.nextCheckAt;
  }

  /**
   * Create from database row
   */
  static fromDatabase(props: AutoSaveSubscriptionProps): AutoSaveSubscription {
    return new AutoSaveSubscription(props);
  }

  /**
   * Create new subscription
   */
  static create(
    props: Omit<AutoSaveSubscriptionProps, 'id' | 'active' | 'lastCheckAt' | 'createdAt' | 'updatedAt'>
  ): AutoSaveSubscription {
    const now = new Date();
    return new AutoSaveSubscription({
      ...props,
      id: '', // To be generated by DB
      active: true,
      lastCheckAt: null,
      createdAt: now,
      updatedAt: now,
    });
  }
}
