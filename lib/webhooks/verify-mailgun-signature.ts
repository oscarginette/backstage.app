/**
 * Mailgun Webhook Signature Verification
 *
 * Verifies HMAC-SHA256 signature from Mailgun webhooks to ensure authenticity.
 *
 * Security features:
 * - HMAC-SHA256 signature verification
 * - Timestamp validation (prevents replay attacks)
 * - Timing-safe comparison (prevents timing attacks)
 *
 * @see https://documentation.mailgun.com/docs/mailgun/user-manual/events/webhooks/#securing-webhooks
 */

import crypto from 'crypto';

/**
 * Verify Mailgun webhook signature
 *
 * Mailgun signature format:
 * - timestamp: Unix timestamp when webhook was sent
 * - token: Random token generated by Mailgun
 * - signature: HMAC-SHA256(timestamp + token, signing_key)
 *
 * @param timestamp - Unix timestamp from X-Mailgun-Timestamp header
 * @param token - Random token from X-Mailgun-Token header
 * @param signature - HMAC signature from X-Mailgun-Signature header
 * @param signingKey - Webhook signing key from Mailgun dashboard
 * @returns true if signature is valid, false otherwise
 */
export function verifyMailgunWebhook(
  timestamp: string,
  token: string,
  signature: string,
  signingKey: string
): boolean {
  try {
    // 1. Check timestamp to prevent replay attacks (max 15 minutes)
    const timestampNum = parseInt(timestamp, 10);

    if (isNaN(timestampNum)) {
      console.error('[Mailgun Webhook] Invalid timestamp format:', timestamp);
      return false;
    }

    const currentTime = Math.floor(Date.now() / 1000);
    const timeDifference = Math.abs(currentTime - timestampNum);

    // Allow 15 minutes window (900 seconds)
    if (timeDifference > 900) {
      console.error('[Mailgun Webhook] Timestamp too old:', {
        timestamp: timestampNum,
        current: currentTime,
        difference: timeDifference,
        maxAllowed: 900,
      });
      return false;
    }

    // 2. Compute HMAC-SHA256 signature
    // Mailgun signature: HMAC-SHA256(timestamp + token, signing_key)
    const payload = timestamp + token;
    const computedSignature = crypto
      .createHmac('sha256', signingKey)
      .update(payload)
      .digest('hex');

    // 3. Compare signatures using timing-safe comparison
    // This prevents timing attacks where attackers measure comparison time
    try {
      const isValid = crypto.timingSafeEqual(
        Buffer.from(signature),
        Buffer.from(computedSignature)
      );

      if (!isValid) {
        console.error('[Mailgun Webhook] Signature mismatch:', {
          expected: computedSignature,
          received: signature,
        });
      }

      return isValid;
    } catch (error) {
      // timingSafeEqual throws if buffer lengths don't match
      console.error('[Mailgun Webhook] Signature length mismatch:', {
        expectedLength: computedSignature.length,
        receivedLength: signature.length,
      });
      return false;
    }
  } catch (error) {
    console.error('[Mailgun Webhook] Signature verification error:', error);
    return false;
  }
}
